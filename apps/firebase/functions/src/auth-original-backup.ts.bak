import {onCall} from "firebase-functions/v2/https";
import {onSchedule} from "firebase-functions/v2/scheduler";
import {getFirestore, Timestamp, FieldValue} from "firebase-admin/firestore";
import {logger} from "firebase-functions";
import {getStorage} from "firebase-admin/storage";
import {getAuth} from "firebase-admin/auth";
import * as crypto from "crypto";
import sgMail, {MailDataRequired} from "@sendgrid/mail";
import {
  isValidEmail,
  isValidPassword,
} from "./utils/validation";
import * as functions from "firebase-functions";
import {defineSecret} from "firebase-functions/params";
import {DEFAULT_REGION, FUNCTION_TIMEOUT} from "./common";
import type {SignupData} from "./utils/validation";
import {createError, withErrorHandling, ErrorCode} from "./utils/errors";
import {withAuth, withResourceAccess, PermissionLevel, RateLimitType} from "./middleware";

// MARK: - Secret Definitions
const SENDGRID_APIKEY = defineSecret("SENDGRID_APIKEY");
const SENDGRID_FROMEMAIL = defineSecret("SENDGRID_FROMEMAIL");
const SENDGRID_TEMPLATES_VERIFICATION = defineSecret("SENDGRID_TEMPLATES_VERIFICATION");
const SENDGRID_TEMPLATES_PASSWORDRESET = defineSecret("SENDGRID_TEMPLATES_PASSWORDRESET");
const SENDGRID_TEMPLATES_INVITE = defineSecret("SENDGRID_TEMPLATES_INVITE");
const FRONTEND_URL = defineSecret("FRONTEND_URL");

// MARK: - Helper function to initialize SendGrid within each function
const initSendGrid = () => {
  const apiKey = SENDGRID_APIKEY.value();
  if (!apiKey || apiKey.length === 0) {
    throw createError(ErrorCode.INTERNAL, "SendGrid API key is not set");
  }
  sgMail.setApiKey(apiKey);
};

// Fix the UserDocument interface
export interface UserDocument {
  id: string;
  email: string;
  displayName?: string;
  firstName?: string;
  lastName?: string;
  phoneNumber?: string | null;
  phoneNumberVerified?: boolean;
  profilePicture?: { path: string; url?: string };
  parentIds: string[];
  childrenIds: string[];
  spouseIds: string[];
  familyTreeId?: string;
  historyBookId?: string;
  gender?: "male" | "female" | "other" | "unspecified";
  isAdmin: boolean;
  canAddMembers: boolean;
  canEdit: boolean;
  createdAt: Date;
  updatedAt: Date;
  emailVerified: boolean;
  emailVerificationToken?: string;
  emailVerificationExpires?: Date | any;
  isPendingSignUp: boolean;
  dataRetentionPeriod: "forever" | "year" | "month" | "week";
  dataRetentionLastUpdated: Date;
  onboardingCompleted: boolean;
  isTreeOwner?: boolean;
  invitationId?: string;
}


// Add interface for invitation data
interface InvitationData {
  inviteeId: string;
  inviteeName: string;
  inviteeEmail: string;
  inviterId: string;
  inviterName: string;
  familyTreeId: string;
  familyTreeName: string;
  invitationToken?: string;
  invitationExpires?: FirebaseFirestore.Timestamp;
  // Additional prefill data
  firstName: string;
  lastName: string;
  dateOfBirth?: Date;
  gender?: string;
  phoneNumber?: string;
  relationship?: string;
}

// Standard error messages
const ERROR_MESSAGES = {
  INVALID_TOKEN: "Invalid verification link. Please request a new verification email.",
  EXPIRED_TOKEN: "Verification link has expired. Please request a new verification email.",
  RATE_LIMIT: "Too many attempts. Please try again later.",
  EMAIL_SEND_FAILED: "Unable to send verification email. Please try again later.",
  USER_NOT_FOUND: "Unable to process request. Please try again.",
  INVALID_REQUEST: "Invalid request. Please try again.",
  VERIFICATION_FAILED: "Email verification failed. Please try again.",
} as const;

// Helper function to generate a secure random token
const generateSecureToken = (): string => {
  const token = crypto.randomBytes(32).toString("hex");
  logger.debug("Generated new token:", {
    tokenLength: token.length,
    tokenFirstChars: token.substring(0, 4),
    tokenLastChars: token.substring(token.length - 4),
  });
  return token;
};

// Helper function to hash a token
const hashToken = (token: string): string => {
  const hashedToken = crypto.createHash("sha256").update(token).digest("hex");
  logger.debug("Hashed token:", {
    originalTokenLength: token.length,
    hashedTokenLength: hashedToken.length,
    originalTokenFirstChars: token.substring(0, 4),
    hashedTokenFirstChars: hashedToken.substring(0, 4),
  });
  return hashedToken;
};


// Helper function to cleanup expired tokens
const cleanupExpiredTokens = async () => {
  const db = getFirestore();
  const now = new Date();

  try {
    // Clean up expired email verification tokens in users collection
    const usersRef = db.collection("users");
    const expiredVerificationTokensQuery = usersRef.where("emailVerificationExpires", "<", now);
    const verificationTokensSnapshot = await expiredVerificationTokensQuery.get();

    if (verificationTokensSnapshot.size > 0) {
      const batch = db.batch();
      verificationTokensSnapshot.docs.forEach((doc) => {
        batch.update(doc.ref, {
          emailVerificationToken: null,
          emailVerificationExpires: null,
        });
      });
      await batch.commit();
      logger.info(`Cleaned up ${verificationTokensSnapshot.size} expired verification tokens`);
    }

    // Clean up expired passwordless tokens
    const passwordlessTokensRef = db.collection("passwordlessTokens");
    const expiredPasswordlessTokensQuery = passwordlessTokensRef.where("expiresAt", "<", now);
    const passwordlessTokensSnapshot = await expiredPasswordlessTokensQuery.get();

    if (passwordlessTokensSnapshot.size > 0) {
      const batch = db.batch();
      passwordlessTokensSnapshot.docs.forEach((doc) => {
        batch.delete(doc.ref);
      });
      logger.info(`Cleaned up ${passwordlessTokensSnapshot.size} expired passwordless tokens`);
    }

    return {
      verificationTokensCleaned: verificationTokensSnapshot.size,
      passwordlessTokensCleaned: passwordlessTokensSnapshot.size,
    };
  } catch (error) {
    logger.error("Error cleaning up expired tokens:", error);
    throw error;
  }
};

// Fix the scheduledTokenCleanup function correctly
export const scheduledTokenCleanup = onSchedule(
  {
    schedule: "every 1 hours",
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.MEDIUM,
    secrets: [],
  },
  async () => {
    try {
      logger.info("Scheduled token cleanup started.");
      const result = await cleanupExpiredTokens();
      logger.info("Scheduled token cleanup finished successfully.", result);
    } catch (error) {
      logger.error("Error in scheduled token cleanup:", error);
    }
  }
);

/**
 * Handles cleanup when a user deletes their account.
 * Performs complete cleanup of user data including:
 * - User document
 * - Family relationships
 * - Stories
 * - Profile picture
 * - Family tree (if owner)
 */
export const handleAccountDeletion = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.MEDIUM,
    secrets: [],
  },
  withResourceAccess(
    async (request) => {
      const {userId} = request.data;

      logger.info(`Starting account deletion for user ${userId}`);
      const db = getFirestore();
      const storage = getStorage();
      let batch = db.batch();
      let operationCount = 0;
      const MAX_OPERATIONS_PER_BATCH = 490;

      const commitBatchIfNeeded = async () => {
        if (operationCount >= MAX_OPERATIONS_PER_BATCH) {
          await batch.commit();
          batch = db.batch();
          operationCount = 0;
          logger.info(`Committed a batch during account deletion for ${userId}.`);
        }
      };

      const userDocRef = db.collection("users").doc(userId);
      const userDoc = await userDocRef.get();

      if (!userDoc.exists) {
        logger.warn(`User ${userId} not found during account deletion attempt.`);
        throw createError(ErrorCode.NOT_FOUND, `User ${userId} not found.`);
      }
      logger.info(`Found user document for ${userId}`);
      const userData = userDoc.data() as UserDocument;
      const familyTreeId = userData?.familyTreeId;
      logger.info(`User ${userId} family tree ID: ${familyTreeId}`);

      // Delete profile picture from storage if it exists
      if (userData?.profilePicture) {
        try {
          await storage.bucket().file(`profile-pictures/${userId}`).delete();
        } catch (error) {
          logger.warn(`Failed to delete profile picture for user ${userId}:`, error);
        }
      }

      if (familyTreeId) {
      // Get all users in the family tree
        const familyMembers = await db.collection("users")
          .where("familyTreeId", "==", familyTreeId)
          .get();

        // Check if user is the tree owner and if all other members are pending
        const isTreeOwner = userData?.isTreeOwner === true;
        const allMembersPending = familyMembers.docs.every((doc) => {
          const data = doc.data();
          return doc.id === userId || data.status === "pending";
        });

        // If user is tree owner and all others are pending, delete the tree and associated data
        if (isTreeOwner && allMembersPending) {
          logger.info(`Deleting family tree ${familyTreeId} and associated data`);

          // Delete all stories associated with the family tree
          const storiesSnapshot = await db.collection("stories")
            .where("familyTreeId", "==", familyTreeId)
            .get();

          storiesSnapshot.docs.forEach((doc) => {
            batch.delete(doc.ref);
            operationCount++;
          });
          await commitBatchIfNeeded();

          // Delete history book document if it exists
          const historyBookDocRef = db.collection("historyBooks").doc(familyTreeId);
          const historyBookDoc = await historyBookDocRef.get();

          if (historyBookDoc.exists) {
            batch.delete(historyBookDocRef);
            operationCount++;
            await commitBatchIfNeeded();
          }

          // Delete family tree document
          const familyTreeDocRef = db.collection("familyTrees").doc(familyTreeId);
          const familyTreeDoc = await familyTreeDocRef.get();

          if (familyTreeDoc.exists) {
            batch.delete(familyTreeDocRef);
            operationCount++;
            await commitBatchIfNeeded();
          }

          // Update status of pending members
          for (const doc of familyMembers.docs) {
            if (doc.id !== userId) {
              batch.update(doc.ref, {
                familyTreeId: null,
                status: null,
                isTreeOwner: false,
              });
              operationCount++;
              await commitBatchIfNeeded();
            }
          }
        } else {
        // If not tree owner or has active members, just remove user from tree
        // and update relationships
          const treeRef = db.collection("familyTrees").doc(familyTreeId);
          const treeDoc = await treeRef.get();
          if (treeDoc.exists) {
            const treeData = treeDoc.data();
            const memberUserIds = treeData?.memberUserIds?.filter((id: string) => id !== userId) || [];
            const adminUserIds = treeData?.adminUserIds?.filter((id: string) => id !== userId) || [];
            batch.update(treeRef, {
              memberUserIds,
              adminUserIds,
            });
            operationCount++;
            await commitBatchIfNeeded();
          }

          // Update relationships for all family members
          for (const memberDoc of familyMembers.docs) {
            if (memberDoc.id === userId) continue;
            const memberData = memberDoc.data();
            const updates: any = {};
            if (memberData.parentIds?.includes(userId)) {
              updates.parentIds = memberData.parentIds.filter((id: string) => id !== userId);
            }
            if (memberData.childrenIds?.includes(userId)) {
              updates.childrenIds = memberData.childrenIds.filter((id: string) => id !== userId);
            }
            if (memberData.spouseIds?.includes(userId)) {
              updates.spouseIds = memberData.spouseIds.filter((id: string) => id !== userId);
            }
            if (Object.keys(updates).length > 0) {
              batch.update(memberDoc.ref, updates);
              operationCount++;
              await commitBatchIfNeeded();
            }
          }
        }
      }

      // Delete user's own stories
      const userStoriesSnapshot = await db.collection("stories")
        .where("authorID", "==", userId)
        .get();

      logger.info(`Found ${userStoriesSnapshot.docs.length} stories to delete for user ${userId}`);
      userStoriesSnapshot.docs.forEach((doc) => {
        batch.delete(doc.ref);
        operationCount++;
      });
      await commitBatchIfNeeded();

      // Delete the user document
      batch.delete(userDocRef);
      operationCount++;

      // Commit any remaining changes in the current batch
      if (operationCount > 0) {
        await batch.commit();
        logger.info(`Committed final batch for account deletion of ${userId}.`);
      }
      logger.info(`Successfully processed all Firestore operations for user ${userId} account deletion.`);

      return {success: true};
    },
    "handleAccountDeletion",
    {
      resourceType: "user",
      resourceIdField: "userId",
      requiredLevel: PermissionLevel.PROFILE_OWNER,
      // Allow admins to delete any account as alternative permission
      additionalPermissionCheck: async (resource, uid) => {
        const db = getFirestore();
        const userDoc = await db.collection("users").doc(uid).get();
        return userDoc.exists && userDoc.data()?.isAdmin === true;
      },
    }
  )
);

/**
 * Updates user profile information
 */
export const updateUserProfile = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.SHORT,
    secrets: [], // Accesses Firestore & Auth
  },
  withResourceAccess(
    async (request) => {
      const {uid, ...profileData} = request.data;

      const db = getFirestore();
      const userRef = db.collection("users").doc(uid);

      // Prepare updates for Firestore, only include fields that are actually provided
      const firestoreUpdates: Partial<UserDocument> = {};
      if (profileData.displayName !== undefined) firestoreUpdates.displayName = profileData.displayName;
      if (profileData.firstName !== undefined) firestoreUpdates.firstName = profileData.firstName;
      if (profileData.lastName !== undefined) firestoreUpdates.lastName = profileData.lastName;
      if (profileData.gender !== undefined) firestoreUpdates.gender = profileData.gender;
      // if (profileData.dateOfBirth !== undefined) firestoreUpdates.dateOfBirth = Timestamp.fromDate(new Date(profileData.dateOfBirth));
      if (profileData.phoneNumber !== undefined) firestoreUpdates.phoneNumber = profileData.phoneNumber; // Handle phone verification separately if needed
      if (profileData.onboardingCompleted !== undefined) firestoreUpdates.onboardingCompleted = profileData.onboardingCompleted;
      if (profileData.dataRetentionPeriod !== undefined) {
        firestoreUpdates.dataRetentionPeriod = profileData.dataRetentionPeriod;
        firestoreUpdates.dataRetentionLastUpdated = Timestamp.now().toDate();
      }
      // Add other updatable fields as necessary
      if (profileData.dateOfBirth !== undefined) {
        try {
          (firestoreUpdates as any).dateOfBirth = Timestamp.fromDate(new Date(profileData.dateOfBirth));
        } catch (e) {
          logger.warn(`Invalid dateOfBirth format for user ${uid} during update: ${profileData.dateOfBirth}`);
        }
      }


      firestoreUpdates.updatedAt = Timestamp.now().toDate();

      // Prepare updates for Firebase Auth (only a subset of fields can be updated here)
      const authUpdates: {displayName?: string; phoneNumber?: string; photoURL?: string} = {};
      if (profileData.displayName !== undefined) authUpdates.displayName = profileData.displayName;
      if (profileData.phoneNumber !== undefined) authUpdates.phoneNumber = profileData.phoneNumber; // Requires verification flow
      // if (profileData.photoURL !== undefined) authUpdates.photoURL = profileData.photoURL;

      try {
        if (Object.keys(authUpdates).length > 0) {
          await getAuth().updateUser(uid, authUpdates);
          logger.info(`Firebase Auth profile updated for user ${uid}.`);
        }
        if (Object.keys(firestoreUpdates).length > 0) {
          await userRef.update(firestoreUpdates);
          logger.info(`Firestore profile updated for user ${uid}.`);
        }
        return {success: true, message: "Profile updated successfully."};
      } catch (error: any) {
        logger.error(`Error updating profile for user ${uid}:`, error);
        throw createError(ErrorCode.INTERNAL, "Failed to update profile.", {originalError: error.message});
      }
    },
    "updateUserProfile",
    {
      resourceType: "user",
      resourceIdField: "uid",
      requiredLevel: [PermissionLevel.PROFILE_OWNER, PermissionLevel.ADMIN],
    }
  )
);

/**
 * Updates user password
 */
export const updateUserPassword = onCall(
  {
    region: DEFAULT_REGION,
    memory: "512MiB",
    timeoutSeconds: FUNCTION_TIMEOUT.MEDIUM,
  },
  withAuth(
    async (request) => {
      const {userId} = request.data;
      logger.info(`Updating password for user ${userId}`);

      // Verify the user exists
      const auth = getAuth();
      try {
        const user = await auth.getUser(userId);
        if (!user) {
          throw createError(ErrorCode.NOT_FOUND, "User not found");
        }

        // Note: Password update should be handled on the client side
        // using Firebase Auth's updatePassword method
        return {success: true};
      } catch (error) {
        logger.error("Failed to verify user:", error);
        throw createError(ErrorCode.INTERNAL, "Failed to verify user");
      }
    },
    "updateUserPassword",
    "auth"
  )
);

/**
 * Initiates password reset process by:
 * - Generating a password reset link
 * - Sending the reset email via SendGrid
 */
export const initiatePasswordReset = onCall({
  region: DEFAULT_REGION,
  memory: "512MiB",
  timeoutSeconds: FUNCTION_TIMEOUT.MEDIUM,
  secrets: [SENDGRID_APIKEY, SENDGRID_FROMEMAIL, SENDGRID_TEMPLATES_PASSWORDRESET, FRONTEND_URL],
}, async (request) => {
  try {
    const {email} = request.data;
    logger.info(`Initiating password reset for email ${email}`);

    // Initialize SendGrid
    initSendGrid();

    const auth = getAuth();

    // Generate the password reset link
    const resetLink = await auth.generatePasswordResetLink(email);

    // Get user details for the email template
    const userRecord = await auth.getUserByEmail(email);
    const displayName = userRecord.displayName || "User";

    // Send email using SendGrid template
    const msg: MailDataRequired = {
      to: email,
      from: SENDGRID_FROMEMAIL.value(),
      templateId: SENDGRID_TEMPLATES_PASSWORDRESET.value(),
      dynamicTemplateData: {
        username: displayName,
        resetLink: resetLink,
      },
    };

    await sgMail.send(msg);
    logger.info(`Successfully sent password reset email to ${email}`);

    return {success: true};
  } catch (error) {
    logger.error("Error in initiatePasswordReset:", error);
    throw new Error(error instanceof Error ? error.message : "Failed to initiate password reset");
  }
});

/**
 * Sends a verification email to a newly registered user
 */
export const sendVerificationEmail = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.SHORT,
    secrets: [SENDGRID_APIKEY, SENDGRID_FROMEMAIL, SENDGRID_TEMPLATES_VERIFICATION, FRONTEND_URL],
  },
  withAuth(
    async (request) => {
      const {userId, email, displayName} = request.data;

      if (!email || !isValidEmail(email)) {
        throw createError(ErrorCode.INVALID_ARGUMENT, "Valid email address is required.");
      }

      initSendGrid();
      const db = getFirestore();
      const userRef = db.collection("users").doc(userId);
      const userDoc = await userRef.get();

      if (!userDoc.exists) {
        throw createError(ErrorCode.NOT_FOUND, "User record not found.");
      }

      const userData = userDoc.data() as UserDocument;
      if (userData.emailVerified) {
        return {success: true, message: "Email is already verified."};
      }

      // Generate verification token and expiry
      const verificationToken = generateSecureToken();
      const hashedToken = hashToken(verificationToken);
      const verificationExpires = Timestamp.fromMillis(Date.now() + 3600000); // 1 hour

      await userRef.update({
        emailVerificationToken: hashedToken,
        emailVerificationExpires: verificationExpires,
        email: email, // Update email if it's being changed during this process
      });

      // Prepare and send email
      const fromEmail = SENDGRID_FROMEMAIL.value();
      const verificationTemplateId = SENDGRID_TEMPLATES_VERIFICATION.value();
      const frontendUrlValue = FRONTEND_URL.value();

      if (!fromEmail || !verificationTemplateId || !frontendUrlValue) {
        logger.error("SendGrid configuration secrets are missing for sendVerificationEmail.");
        throw createError(ErrorCode.INTERNAL, "Email service configuration error.");
      }

      const verificationLink = `${frontendUrlValue}/verify-email?token=${verificationToken}`;
      const msg: MailDataRequired = {
        to: email,
        from: {
          email: fromEmail,
          name: "Dynasty App",
        },
        templateId: verificationTemplateId,
        dynamicTemplateData: {
          userName: displayName || userData.firstName || "User",
          verificationLink: verificationLink,
        },
      };

      try {
        await sgMail.send(msg);
        logger.info(`Verification email sent to ${email} for user ${request.auth?.uid}`);
        return {success: true, message: "Verification email sent successfully."};
      } catch (error) {
        logger.error("Failed to send verification email:", {error, userId: request.auth?.uid, email});
        throw createError(ErrorCode.INTERNAL, ERROR_MESSAGES.EMAIL_SEND_FAILED);
      }
    },
    "sendVerificationEmail",
    "auth", // Authentication level
    {
      type: RateLimitType.AUTH,
      maxRequests: 3, // 3 verification emails per hour
      windowSeconds: 3600, // 1 hour window
    }
  )
);

/**
 * Verifies a user's email address using the token from the verification link
 */
export const verifyEmail = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.SHORT,
    secrets: [],
  },
  withErrorHandling(async (request) => {
    const {token} = request.data;

    if (!token || typeof token !== "string") {
      throw createError(ErrorCode.INVALID_ARGUMENT, "Verification token is required.");
    }

    const db = getFirestore();
    const hashedToken = hashToken(token);

    // Find user by token
    const usersRef = db.collection("users");
    const query = usersRef.where("emailVerificationToken", "==", hashedToken).limit(1);
    const snapshot = await query.get();

    if (snapshot.empty) {
      throw createError(ErrorCode.INVALID_ARGUMENT, ERROR_MESSAGES.INVALID_TOKEN);
    }

    const userDoc = snapshot.docs[0];
    const userData = userDoc.data() as UserDocument;

    // Check if token expired
    if (userData.emailVerificationExpires && userData.emailVerificationExpires.toMillis() < Date.now()) {
      // Clear expired token
      await userDoc.ref.update({
        emailVerificationToken: null,
        emailVerificationExpires: null,
      });
      throw createError(ErrorCode.INVALID_ARGUMENT, ERROR_MESSAGES.EXPIRED_TOKEN);
    }

    // Mark email as verified and clear token
    await userDoc.ref.update({
      emailVerified: true,
      emailVerificationToken: null,
      emailVerificationExpires: null,
      updatedAt: FieldValue.serverTimestamp(),
    });

    // Also update Firebase Auth user record
    try {
      await getAuth().updateUser(userDoc.id, {emailVerified: true});
      logger.info(`Email verified for user ${userDoc.id} via token.`);
    } catch (authError) {
      logger.error(`Failed to update Firebase Auth record for user ${userDoc.id} after email verification:`, authError);
    }

    return {success: true, message: "Email verified successfully."};
  }, "verifyEmail")
);

/**
 * Handles the signup process, which now only:
 * - Creates Firebase Auth account
 * - Sends verification email
 *
 * Firestore document creation is now handled in completeOnboarding
 */
export const handleSignUp = onCall({
  region: DEFAULT_REGION,
  memory: "512MiB",
  timeoutSeconds: FUNCTION_TIMEOUT.MEDIUM,
  secrets: [SENDGRID_APIKEY, SENDGRID_FROMEMAIL, SENDGRID_TEMPLATES_VERIFICATION, FRONTEND_URL],
}, async (request) => {
  const signupData: SignupData = request.data;
  logger.info(`Starting simplified signup process for email: ${signupData.email}`);

  try {
    // Initialize SendGrid
    initSendGrid();

    // Validate email and password
    if (!isValidEmail(signupData.email)) {
      throw new Error("Invalid email address");
    }

    if (!isValidPassword(signupData.password)) {
      throw new Error("Password must be at least 8 characters and include numbers and letters");
    }

    const auth = getAuth();
    const db = getFirestore();

    // Check if email already exists
    try {
      await auth.getUserByEmail(signupData.email);
      throw new functions.https.HttpsError(
        "already-exists",
        "An account with this email already exists"
      );
    } catch (error: any) {
      // Proceed only if error code is auth/user-not-found
      if (error.code !== "auth/user-not-found") {
        if (error instanceof functions.https.HttpsError) {
          throw error;
        }
        throw new functions.https.HttpsError(
          "already-exists",
          "An account with this email already exists"
        );
      }
    }

    // Create the Firebase Auth account
    const userRecord = await auth.createUser({
      email: signupData.email,
      password: signupData.password,
      emailVerified: false,
    });

    const userId = userRecord.uid;

    // Create a minimal user document in Firestore
    // This is needed so that we can later update it with onboarding data
    const userRef = db.collection("users").doc(userId);
    await userRef.set({
      id: userId,
      email: signupData.email,
      createdAt: new Date(),
      updatedAt: new Date(),
      emailVerified: false,
      onboardingCompleted: false,
      dataRetentionPeriod: "forever",
      dataRetentionLastUpdated: new Date(),
    });

    // Generate verification token and send verification email
    const verificationToken = generateSecureToken();
    const hashedToken = hashToken(verificationToken);
    const expiryTime = new Date();
    expiryTime.setMinutes(expiryTime.getMinutes() + 30); // Token expires in 30 minutes

    // Update user document with verification token
    await userRef.update({
      emailVerificationToken: hashedToken,
      emailVerificationExpires: expiryTime,
    });

    // Send verification email
    const verificationLink = `${FRONTEND_URL.value()}/verify-email/confirm?uid=${userId}&token=${verificationToken}`;
    const msg: MailDataRequired = {
      to: signupData.email,
      from: SENDGRID_FROMEMAIL.value(),
      templateId: SENDGRID_TEMPLATES_VERIFICATION.value(),
      dynamicTemplateData: {
        username: signupData.email.split("@")[0], // Use email username as fallback since we don't have names yet
        verificationLink: verificationLink,
      },
    };

    await sgMail.send(msg);
    logger.info(`Successfully completed simplified signup process for user ${userId}`);

    return {
      success: true,
      userId,
    };
  } catch (error: any) {
    logger.error("Error in handleSignUp:", error);
    if (error instanceof functions.https.HttpsError) {
      throw error; // Re-throw HttpsError instances as is
    }
    // For other types of errors, throw a generic HttpsError
    const message = error?.message || "Failed to complete signup process";
    throw new functions.https.HttpsError("internal", message, error);
  }
});

/**
 * Handles the onboarding process, which:
 * - Updates the user document with profile information
 * - Creates family tree document (for new users) or links to existing tree (for invited users)
 * - Creates history book document
 * - Sets up necessary relationships
 * - Handles migration of data for invited users
 */
export const completeOnboarding = onCall({
  region: DEFAULT_REGION,
  memory: "512MiB",
  timeoutSeconds: FUNCTION_TIMEOUT.MEDIUM,
}, async (request) => {
  const {userId, firstName, lastName, dateOfBirth, gender, phoneNumber, displayName} = request.data;

  logger.info(`Starting onboarding process for user: ${userId}`);

  try {
    const db = getFirestore();
    const auth = getAuth();

    // Validate inputs
    if (!userId || !firstName || !lastName) {
      throw new Error("Required fields missing. Please provide userId, firstName, and lastName.");
    }

    // Get the Auth user
    let authUser;
    try {
      authUser = await auth.getUser(userId);
    } catch (error) {
      logger.error(`Auth user not found for ID: ${userId}`, error);
      throw new Error("Auth user not found. Please sign up first.");
    }

    // Get the user document
    const userRef = db.collection("users").doc(userId);
    const userDoc = await userRef.get();

    const batch = db.batch();

    // Use the provided displayName or create one from firstName and lastName
    const finalDisplayName = displayName || `${firstName} ${lastName}`.trim();

    // Update Firebase Auth profile with displayName
    try {
      await auth.updateUser(userId, {
        displayName: finalDisplayName,
      });
    } catch (error) {
      logger.warn(`Could not update Auth displayName for user ${userId}`, error);
      // Continue with the process even if Auth update fails
    }

    // If user exists in Auth but not in Firestore, create the Firestore document
    if (!userDoc.exists && authUser) {
      logger.info(`Creating Firestore document for user ${userId}`);

      // Create a new family tree for the user
      const familyTreeRef = db.collection("familyTrees").doc();
      const familyTreeId = familyTreeRef.id;

      // Create a new history book for the user
      const historyBookRef = db.collection("historyBooks").doc();
      const historyBookId = historyBookRef.id;

      // Create family tree document
      batch.set(familyTreeRef, {
        id: familyTreeId,
        ownerUserId: userId,
        memberUserIds: [userId],
        adminUserIds: [userId],
        treeName: `${firstName}'s Family Tree`,
        memberCount: 1,
        createdAt: new Date(),
        updatedAt: new Date(),
        isPrivate: true,
      });

      // Create history book document
      batch.set(historyBookRef, {
        id: historyBookId,
        ownerUserId: userId,
        familyTreeId: familyTreeId,
        title: `${firstName}'s History Book`,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      // Create user document
      const userData: UserDocument = {
        id: userId,
        displayName: finalDisplayName,
        email: authUser.email || "",
        firstName: firstName,
        lastName: lastName,
        phoneNumber: phoneNumber || authUser.phoneNumber || null,
        parentIds: [],
        childrenIds: [],
        spouseIds: [],
        familyTreeId,
        historyBookId,
        gender: gender || "other",
        isAdmin: true,
        canAddMembers: true,
        canEdit: true,
        isPendingSignUp: false,
        createdAt: new Date(),
        updatedAt: new Date(),
        emailVerified: true,
        dataRetentionPeriod: "forever",
        dataRetentionLastUpdated: new Date(),
        onboardingCompleted: true,
      };

      batch.set(userRef, userData);

      // Update Firebase Auth user to ensure email is verified
      await auth.updateUser(userId, {
        emailVerified: true,
      });

      // Commit the batch and return success
      await batch.commit();

      logger.info(`Successfully created Firestore documents for user ${userId}`);

      return {
        success: true,
        userId,
        familyTreeId,
        historyBookId,
      };
    }

    // For users that already have a Firestore document
    if (userDoc.exists) {
      const userData = userDoc.data() as Partial<UserDocument>;

      // Check if this is an invited user
      const invitationId = userData.invitationId;
      let invitation: any = null;
      let oldUserId: string | null = null;
      let familyTreeId: string | null = null;
      let prefillData: any = null;
      let oldUserParentIds: string[] = [];
      let oldUserChildrenIds: string[] = [];
      let oldUserSpouseIds: string[] = [];

      if (invitationId) {
        logger.info(`Processing invited user onboarding for invitation: ${invitationId}`);
        const invitationDoc = await db.collection("invitations").doc(invitationId).get();

        if (invitationDoc.exists) {
          invitation = invitationDoc.data();
          if (invitation) {
            oldUserId = invitation.inviteeId;
            familyTreeId = invitation.familyTreeId;
            prefillData = invitation.prefillData;

            logger.info(`Found invitation with prefill data: ${JSON.stringify(prefillData || {})}`);

            // Get the old user document if it exists
            if (oldUserId) {
              const oldUserDoc = await db.collection("users").doc(oldUserId).get();
              if (oldUserDoc.exists) {
                logger.info(`Found old user document for ${oldUserId}, will migrate relationships`);
                // Extract relationship data from old user document
                const oldUserData = oldUserDoc.data();
                oldUserParentIds = oldUserData?.parentIds || [];
                oldUserChildrenIds = oldUserData?.childrenIds || [];
                oldUserSpouseIds = oldUserData?.spouseIds || [];
                logger.info(`Retrieved relationship data from old user: parentIds(${oldUserParentIds.length}), childrenIds(${oldUserChildrenIds.length}), spouseIds(${oldUserSpouseIds.length})`);
              }
            }
          }
        }
      }

      // For non-invited users, create a new family tree
      if (!familyTreeId) {
        const familyTreeRef = db.collection("familyTrees").doc();
        familyTreeId = familyTreeRef.id;

        batch.set(familyTreeRef, {
          id: familyTreeId,
          ownerUserId: userId,
          memberUserIds: [userId],
          adminUserIds: [userId],
          treeName: `${firstName}'s Family Tree`,
          memberCount: 1,
          createdAt: new Date(),
          updatedAt: new Date(),
          isPrivate: true,
        });
      } else {
        // For invited users, add them to the existing family tree
        const familyTreeRef = db.collection("familyTrees").doc(familyTreeId);
        const familyTreeDoc = await familyTreeRef.get();

        if (familyTreeDoc.exists) {
          const treeData = familyTreeDoc.data();
          if (treeData) {
            const memberUserIds = treeData.memberUserIds || [];

            if (!memberUserIds.includes(userId)) {
              batch.update(familyTreeRef, {
                memberUserIds: [...memberUserIds, userId],
                memberCount: (treeData.memberCount || 0) + 1,
                updatedAt: new Date(),
              });
            }
          }
        }
      }

      // Create history book document
      const historyBookRef = db.collection("historyBooks").doc();
      const historyBookId = historyBookRef.id;
      batch.set(historyBookRef, {
        id: historyBookId,
        ownerUserId: userId,
        familyTreeId: familyTreeId,
        title: `${firstName}'s History Book`,
        createdAt: new Date(),
        updatedAt: new Date(),
      });

      // Use prefilled data from invitation if available and not overridden by user input
      const finalFirstName = firstName || (prefillData?.firstName) || "";
      const finalLastName = lastName || (prefillData?.lastName) || "";
      const finalDateOfBirth = dateOfBirth || (prefillData?.dateOfBirth) || null;
      const finalGender = gender || (prefillData?.gender) || "other";
      const finalPhoneNumber = phoneNumber || (prefillData?.phoneNumber) || null;

      // Update user document with onboarding information
      batch.update(userRef, {
        displayName: finalDisplayName,
        firstName: finalFirstName,
        lastName: finalLastName,
        dateOfBirth: finalDateOfBirth instanceof Date ? finalDateOfBirth : finalDateOfBirth ? new Date(finalDateOfBirth) : null,
        gender: finalGender,
        phoneNumber: finalPhoneNumber,
        familyTreeId,
        historyBookId,
        parentIds: oldUserParentIds,
        childrenIds: oldUserChildrenIds,
        spouseIds: oldUserSpouseIds,
        isAdmin: true,
        canAddMembers: true,
        canEdit: true,
        isPendingSignUp: false,
        updatedAt: new Date(),
        onboardingCompleted: true,
        // Remove the invitation ID as it's no longer needed
        invitationId: null,
      });

      // If this is an invited user, handle relationship migrations
      if (oldUserId && invitation) {
        logger.info(`Migrating relationships for invited user from ${oldUserId} to ${userId}`);

        // Update all family trees where the old user is a member
        const familyTreesQuery = await db.collection("familyTrees")
          .where("memberUserIds", "array-contains", oldUserId)
          .get();

        familyTreesQuery.forEach((doc) => {
          const treeData = doc.data();
          batch.update(doc.ref, {
            memberUserIds: (treeData.memberUserIds || []).map((id: string) => id === oldUserId ? userId : id),
            adminUserIds: (treeData.adminUserIds || []).map((id: string) => id === oldUserId ? userId : id),
            updatedAt: new Date(),
          });
        });

        // Update history books
        const historyBooksQuery = await db.collection("historyBooks")
          .where("ownerUserId", "==", oldUserId)
          .get();

        historyBooksQuery.forEach((doc) => {
          batch.update(doc.ref, {
            ownerUserId: userId,
            updatedAt: new Date(),
          });
        });

        // Update stories
        const storiesQuery = await db.collection("stories")
          .where("authorId", "==", oldUserId)
          .get();

        storiesQuery.forEach((doc) => {
          batch.update(doc.ref, {
            authorId: userId,
            updatedAt: new Date(),
          });
        });

        // Update all relationship references in other user documents
        const [parentRefs, childRefs, spouseRefs] = await Promise.all([
          db.collection("users").where("parentIds", "array-contains", oldUserId).get(),
          db.collection("users").where("childrenIds", "array-contains", oldUserId).get(),
          db.collection("users").where("spouseIds", "array-contains", oldUserId).get(),
        ]);

        const updateDoc = (doc: any, field: string) => {
          const data = doc.data();
          if (data[field]?.includes(oldUserId)) {
            batch.update(doc.ref, {
              [field]: data[field].map((id: string) => id === oldUserId ? userId : id),
              updatedAt: new Date(),
            });
          }
        };

        parentRefs.forEach((doc) => updateDoc(doc, "parentIds"));
        childRefs.forEach((doc) => updateDoc(doc, "childrenIds"));
        spouseRefs.forEach((doc) => updateDoc(doc, "spouseIds"));

        // Update any comments or reactions that reference the old user ID
        const commentsQuery = await db.collection("comments")
          .where("authorId", "==", oldUserId)
          .get();

        commentsQuery.forEach((doc) => {
          batch.update(doc.ref, {
            authorId: userId,
            updatedAt: new Date(),
          });
        });

        const reactionsQuery = await db.collection("reactions")
          .where("userId", "==", oldUserId)
          .get();

        reactionsQuery.forEach((doc) => {
          batch.update(doc.ref, {
            userId: userId,
            updatedAt: new Date(),
          });
        });

        // Delete the old user document
        const oldUserDoc = await db.collection("users").doc(oldUserId).get();
        if (oldUserDoc.exists) {
          batch.delete(oldUserDoc.ref);
        }
      }

      // Commit all Firestore operations
      await batch.commit();

      logger.info(`Successfully completed onboarding process for user ${userId}`);

      return {
        success: true,
        userId,
        familyTreeId,
        historyBookId,
      };
    }

    throw new Error("Unexpected user document state. Please contact support.");
  } catch (error) {
    logger.error("Error in completeOnboarding:", error);
    throw new Error(error instanceof Error ? error.message : "Failed to complete onboarding process");
  }
});

/**
 * Updates user's data retention settings
 */
export const updateDataRetention = onCall({
  region: DEFAULT_REGION,
  memory: "512MiB",
  timeoutSeconds: FUNCTION_TIMEOUT.MEDIUM,
}, async (request) => {
  try {
    const {userId, retentionPeriod} = request.data;
    logger.info(`Updating data retention settings for user ${userId} to ${retentionPeriod}`);

    const db = getFirestore();
    const userRef = db.collection("users").doc(userId);
    const userDoc = await userRef.get();

    if (!userDoc.exists) {
      throw new Error("User not found");
    }

    await userRef.update({
      dataRetentionPeriod: retentionPeriod,
      dataRetentionLastUpdated: new Date(),
      updatedAt: new Date(),
    });

    logger.info(`Successfully updated data retention settings for user ${userId}`);
    return {success: true};
  } catch (error) {
    logger.error("Error in updateDataRetention:", error);
    throw new Error(error instanceof Error ? error.message : "Failed to update data retention settings");
  }
});

/**
 * Sends an invitation email to a newly added family member
 */
export const sendFamilyTreeInvitation = onCall({
  region: DEFAULT_REGION,
  memory: "512MiB",
  timeoutSeconds: FUNCTION_TIMEOUT.MEDIUM,
  secrets: [SENDGRID_APIKEY, SENDGRID_FROMEMAIL, SENDGRID_TEMPLATES_INVITE, FRONTEND_URL],
}, async (request) => {
  const invitationData: InvitationData = request.data;
  logger.info(`Starting invitation process for ${invitationData.inviteeEmail} to family tree ${invitationData.familyTreeId}`);

  try {
    // Initialize SendGrid
    initSendGrid();

    // Input validation
    if (!invitationData.inviteeId || !invitationData.inviteeEmail || !invitationData.inviterId || !invitationData.familyTreeId) {
      throw new Error(ERROR_MESSAGES.INVALID_REQUEST);
    }

    // Verify that the inviter is the authenticated user
    const auth = request.auth;
    if (!auth) {
      throw new Error("Authentication required");
    }

    // Override inviterId with authenticated user's ID
    invitationData.inviterId = auth.uid;

    // Get the inviter's display name from Firestore
    const db = getFirestore();
    const inviterDoc = await db.collection("users").doc(auth.uid).get();
    if (inviterDoc.exists) {
      const inviterData = inviterDoc.data();
      if (inviterData && inviterData.displayName) {
        invitationData.inviterName = inviterData.displayName;
      } else {
        invitationData.inviterName = "A family member"; // Fallback
      }
    } else {
      invitationData.inviterName = "A family member"; // Fallback if user not found
    }

    // Generate invitation token
    const invitationToken = generateSecureToken();
    const hashedToken = hashToken(invitationToken);

    // Set expiry time to 7 days from now
    const now = new Date();
    const expiryTime = new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000);
    const firestoreExpiry = Timestamp.fromDate(expiryTime);

    // Store invitation data in Firestore
    const invitationRef = db.collection("familyInvitations").doc();
    await invitationRef.set({
      id: invitationRef.id,
      inviteeId: invitationData.inviteeId,
      inviteeEmail: invitationData.inviteeEmail,
      inviterId: invitationData.inviterId,
      familyTreeId: invitationData.familyTreeId,
      token: hashedToken,
      expires: firestoreExpiry,
      status: "pending",
      createdAt: now,
      // Store prefill data
      prefillData: {
        firstName: invitationData.firstName,
        lastName: invitationData.lastName,
        dateOfBirth: invitationData.dateOfBirth,
        gender: invitationData.gender,
        phoneNumber: invitationData.phoneNumber,
        relationshipToInviter: invitationData.relationship,
      },
    });

    // Create invitation link with token
    const invitationLink = `${FRONTEND_URL.value()}/signup/invited?token=${invitationToken}&id=${invitationRef.id}`;

    // Send invitation email using SendGrid template
    const msg: MailDataRequired = {
      to: invitationData.inviteeEmail,
      from: SENDGRID_FROMEMAIL.value(),
      templateId: SENDGRID_TEMPLATES_INVITE.value(),
      dynamicTemplateData: {
        name: invitationData.inviteeName,
        inviterName: invitationData.inviterName,
        familyTreeName: invitationData.familyTreeName,
        acceptLink: invitationLink,
        year: new Date().getFullYear(),
      },
    };

    await sgMail.send(msg);
    logger.info(`Successfully sent invitation email to ${invitationData.inviteeEmail}`);

    return {
      success: true,
      invitationId: invitationRef.id,
    };
  } catch (error) {
    logger.error("Error sending invitation email:", error);
    throw new Error(error instanceof Error ? error.message : "Failed to send invitation");
  }
});

/**
 * Accepts a family invitation.
 */
export const acceptFamilyInvitation = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.MEDIUM,
    secrets: [], // Accesses Firestore & Auth
  },
  withErrorHandling(async (request) => {
    const {auth, data} = request;
    const {invitationToken} = data;

    if (!auth) {
      throw createError(ErrorCode.UNAUTHENTICATED, "User must be authenticated to accept an invitation.");
    }
    if (!invitationToken || typeof invitationToken !== "string") {
      throw createError(ErrorCode.INVALID_ARGUMENT, "Invitation token is required.");
    }

    const db = getFirestore();
    const hashedToken = hashToken(invitationToken);
    const currentUserId = auth.uid;

    const invitationsRef = db.collection("familyInvitations");
    const query = invitationsRef.where("token", "==", hashedToken).limit(1);
    const snapshot = await query.get();

    if (snapshot.empty) {
      throw createError(ErrorCode.INVALID_ARGUMENT, "Invalid or expired invitation link.");
    }

    const invitationDoc = snapshot.docs[0];
    const invitationData = invitationDoc.data() as any; // Cast to 'any' or define a proper type

    if (invitationData.status !== "pending") {
      throw createError(ErrorCode.ALREADY_EXISTS, `Invitation has already been ${invitationData.status}.`);
    }

    if (invitationData.expires.toMillis() < Date.now()) {
      await invitationDoc.ref.update({status: "expired", updatedAt: FieldValue.serverTimestamp()});
      throw createError(ErrorCode.INVALID_ARGUMENT, "Invitation link has expired.");
    }

    // Check if the authenticated user's email matches the inviteeEmail (after converting to lowercase)
    const userAuthRecord = await getAuth().getUser(currentUserId);
    if (userAuthRecord.email?.toLowerCase() !== invitationData.inviteeEmail.toLowerCase()) {
      logger.warn(
        `User ${currentUserId} (${userAuthRecord.email}) attempted to accept invitation for ${invitationData.inviteeEmail}`
      );
      throw createError(
        ErrorCode.PERMISSION_DENIED,
        "This invitation is intended for a different email address."
      );
    }

    // Update user's familyTreeId
    const userRef = db.collection("users").doc(currentUserId);
    await userRef.update({
      familyTreeId: invitationData.familyTreeId,
      updatedAt: FieldValue.serverTimestamp(),
      // Potentially update other fields based on prefillData from invitation
      ...(invitationData.prefillData?.firstName && {firstName: invitationData.prefillData.firstName}),
      ...(invitationData.prefillData?.lastName && {lastName: invitationData.prefillData.lastName}),
      ...(invitationData.prefillData?.gender && {gender: invitationData.prefillData.gender}),
      ...(invitationData.prefillData?.dateOfBirth && {dateOfBirth: Timestamp.fromDate(new Date(invitationData.prefillData.dateOfBirth))}), // Ensure date format is handled
      ...(invitationData.prefillData?.phoneNumber && {phoneNumber: invitationData.prefillData.phoneNumber}),
    });

    // Update invitation status
    await invitationDoc.ref.update({
      status: "accepted",
      acceptedByUserId: currentUserId,
      acceptedAt: FieldValue.serverTimestamp(),
      updatedAt: FieldValue.serverTimestamp(),
    });

    // TODO: Add logic to establish relationships in the family tree based on `invitationData.prefillData.relationshipToInviter`
    // This might involve updating the inviter's and invitee's parentIds, childrenIds, spouseIds arrays.
    // Example: if relationshipToInviter is "child", add currentUserId to inviterData.childrenIds and inviterId to userData.parentIds.
    // This requires fetching the inviter's document and potentially using a transaction or batch write.
    logger.info(`User ${currentUserId} accepted invitation ${invitationDoc.id} to family tree ${invitationData.familyTreeId}.`);

    // Potentially trigger other actions, like creating a default history book entry or sending a welcome notification.

    return {
      success: true,
      message: "Invitation accepted successfully!",
      familyTreeId: invitationData.familyTreeId,
    };
  }, "acceptFamilyInvitation")
);

/**
 * Retrieves a list of family members for a given family tree ID.
 * Ensures the calling user is part of that family tree.
 */
export const getFamilyMembers = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.SHORT,
    secrets: [], // Accesses Firestore
  },
  withResourceAccess(
    async (request) => {
      const {familyTreeId} = request.data;

      const db = getFirestore();
      const membersSnapshot = await db.collection("users")
        .where("familyTreeId", "==", familyTreeId)
        .orderBy("lastName") // Optional: order by a relevant field
        .orderBy("firstName")
        .get();

      if (membersSnapshot.empty) {
        return {familyMembers: [], message: "No members found in this family tree."};
      }

      const familyMembers = membersSnapshot.docs.map((doc) => {
        const memberData = doc.data() as UserDocument;
        // Selectively return fields to avoid exposing sensitive data unnecessarily
        return {
          id: doc.id,
          displayName: memberData.displayName,
          firstName: memberData.firstName,
          lastName: memberData.lastName,
          email: memberData.email, // Consider if email should always be returned
          // photoURL: memberData.photoURL,
          profilePictureUrl: memberData.profilePicture?.url,
          gender: memberData.gender,
        // Add other relevant non-sensitive fields
        };
      });

      return {familyMembers};
    },
    "getFamilyMembers",
    {
      resourceType: "family_tree",
      resourceIdField: "familyTreeId",
      requiredLevel: PermissionLevel.FAMILY_MEMBER,
    }
  )
);

/**
 * Resets the user's password using a token.
 */
export const resetPassword = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.SHORT,
    secrets: [], // No direct secrets, but interacts with Firestore & Auth
  },
  withErrorHandling(async (request) => {
    const {token, newPassword} = request.data;

    if (!token || typeof token !== "string") {
      throw createError(ErrorCode.INVALID_ARGUMENT, "Reset token is required.");
    }
    if (!newPassword || !isValidPassword(newPassword)) {
      throw createError(ErrorCode.INVALID_ARGUMENT, "A valid new password is required (min 8 chars, letter, number).");
    }

    const db = getFirestore();
    const hashedToken = hashToken(token);

    // Find token in passwordResetTokens collection
    const tokenRef = db.collection("passwordResetTokens").doc(hashedToken);
    const tokenDoc = await tokenRef.get();

    if (!tokenDoc.exists) {
      throw createError(ErrorCode.INVALID_ARGUMENT, "Invalid or expired password reset link.");
    }

    const tokenData = tokenDoc.data() as { userId: string; email: string; expiresAt: Timestamp };

    if (tokenData.expiresAt.toMillis() < Date.now()) {
      await tokenRef.delete(); // Clean up expired token
      throw createError(ErrorCode.INVALID_ARGUMENT, "Password reset link has expired. Please request a new one.");
    }

    // Update Firebase Auth user's password
    try {
      await getAuth().updateUser(tokenData.userId, {password: newPassword});
      logger.info(`Password reset successfully for user ${tokenData.userId}`);

      // Delete the used reset token
      await tokenRef.delete();

      // Optionally: Update last password change timestamp in user document
      await db.collection("users").doc(tokenData.userId).update({
        updatedAt: FieldValue.serverTimestamp(), // Or a specific passwordLastChanged field
      });

      return {success: true, message: "Password reset successfully."};
    } catch (error) {
      logger.error("Failed to reset password in Firebase Auth:", {error, userId: tokenData.userId});
      throw createError(ErrorCode.INTERNAL, "Failed to reset password. Please try again.");
    }
  }, "resetPassword")
);

/**
 * Creates a user document in Firestore.
 * This is typically called after a user is created in Firebase Auth.
 */
export const createUserDocument = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.SHORT,
    secrets: [], // Accesses Firestore
  },
  withAuth(
    async (request) => {
      const {uid, email, displayName, phoneNumber, photoURL, invitationId, familyTreeId: initialFamilyTreeId, firstName, lastName, gender, dateOfBirth} = request.data;

      if (!uid || !email) {
        throw createError(ErrorCode.INVALID_ARGUMENT, "User ID and email are required.");
      }

      const db = getFirestore();
      const userRef = db.collection("users").doc(uid);
      const userDoc = await userRef.get();

      if (userDoc.exists) {
        logger.info(`User document for ${uid} already exists.`);
        // Optionally update if it exists but is missing some info from Auth, or return error/success
        return {success: true, message: "User document already exists.", userId: uid};
      }

      const now = Timestamp.now();
      // Fetch Auth user record to get the latest emailVerified status
      let authUserRecord;
      try {
        authUserRecord = await getAuth().getUser(uid);
      } catch (e) {
        logger.error(`Failed to fetch auth record for user ${uid} during document creation:`, e);
        throw createError(ErrorCode.INTERNAL, "Failed to verify user auth status for document creation.");
      }

      const newUser: UserDocument = {
        id: uid,
        email: email,
        firstName: firstName || displayName?.split(" ")[0] || "",
        lastName: lastName || displayName?.split(" ").slice(1).join(" ") || "",
        displayName: displayName || `${firstName || ""} ${lastName || ""}`.trim(),
        phoneNumber: phoneNumber || null,
        phoneNumberVerified: false, // Assuming phone not verified at this stage
        profilePicture: photoURL ? {url: photoURL, path: ""} : undefined, // Store as profilePicture if structure matches
        parentIds: [],
        childrenIds: [],
        spouseIds: [],
        familyTreeId: initialFamilyTreeId || undefined, // Set if provided during signup (e.g. from invite)
        historyBookId: undefined, // Or generate one
        gender: gender || "unspecified",
        isAdmin: false, // Default to not admin
        canAddMembers: true, // Default permissions
        canEdit: true,
        createdAt: now.toDate(), // Store as Date
        updatedAt: now.toDate(), // Store as Date
        emailVerified: authUserRecord.emailVerified, // Get from Auth record
        isPendingSignUp: false, // User creation implies signup is no longer pending
        dataRetentionPeriod: "forever",
        dataRetentionLastUpdated: now.toDate(),
        onboardingCompleted: false,
        invitationId: invitationId || undefined,
      };
      if (dateOfBirth) {
        try {
          (newUser as any).dateOfBirth = Timestamp.fromDate(new Date(dateOfBirth));
        } catch (e) {
          logger.warn(`Invalid dateOfBirth format for user ${uid}: ${dateOfBirth}`);
        }
      }

      await userRef.set(newUser);
      logger.info(`User document created for ${uid}`);

      // If an invitationId is present, mark the invitation as accepted/used
      if (invitationId) {
        try {
          const invitationRef = db.collection("familyInvitations").doc(invitationId);
          const invitationDoc = await invitationRef.get();
          if (invitationDoc.exists) {
            await invitationRef.update({
              status: "accepted",
              acceptedAt: now,
              acceptedByUserId: uid,
            });
            logger.info(`Invitation ${invitationId} marked as accepted by user ${uid}.`);
          }
        } catch (invError) {
          logger.error(`Error updating invitation ${invitationId} after user creation:`, invError);
        }
      }

      return {success: true, userId: uid, message: "User document created successfully."};
    },
    "createUserDocument",
    "auth"
  )
);

/**
 * Signs up a new user with email and password.
 */
export const signUpWithEmail = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.MEDIUM, // Increased for Auth + DB operations
    secrets: [SENDGRID_APIKEY, SENDGRID_FROMEMAIL, SENDGRID_TEMPLATES_VERIFICATION, FRONTEND_URL],
  },
  withErrorHandling(async (request) => {
    const {email, password, displayName, firstName, lastName, invitationId, familyTreeId: initialFamilyTreeId, gender, dateOfBirth, phoneNumber} = request.data as SignupData;

    if (!email || !isValidEmail(email)) {
      throw createError(ErrorCode.INVALID_ARGUMENT, "A valid invitee email address is required.");
    }
    if (!password || !isValidPassword(password)) {
      throw createError(ErrorCode.INVALID_ARGUMENT, "Password must be at least 8 characters long and include a letter and a number.");
    }

    const auth = getAuth();
    let newUserRecord;
    try {
      newUserRecord = await auth.createUser({
        email,
        password,
        displayName: displayName || `${firstName || ""} ${lastName || ""}`.trim(),
        emailVerified: false, // Email will be verified via separate step
        phoneNumber: phoneNumber || undefined,
      });
      logger.info(`User created in Firebase Auth with UID: ${newUserRecord.uid}`);
    } catch (error: any) {
      logger.error("Error creating user in Firebase Auth:", error);
      if (error.code === "auth/email-already-exists") {
        throw createError(ErrorCode.ALREADY_EXISTS, "An account with this email already exists.");
      }
      throw createError(ErrorCode.INTERNAL, "Failed to create user account.", {originalError: error.message});
    }

    // Create user document in Firestore
    try {
      // Construct the request object as expected by a callable function
      const createUserDocumentRequest = {
        data: {
          uid: newUserRecord.uid,
          email,
          displayName: newUserRecord.displayName,
          phoneNumber: newUserRecord.phoneNumber,
          photoURL: newUserRecord.photoURL,
          invitationId,
          familyTreeId: initialFamilyTreeId,
          firstName,
          lastName,
          gender,
          dateOfBirth,
        },
        auth: {uid: newUserRecord.uid, token: {} as any}, // Mock auth context
      };
      await (createUserDocument as any)(createUserDocumentRequest as any);
    } catch (dbError: any) {
      logger.error(`Error creating Firestore document for user ${newUserRecord.uid} after signup:`, dbError);
      // Potentially try to delete the Auth user if DB creation fails critically, or mark for cleanup
      // For now, log and let admin handle inconsistencies if they arise.
      // Throwing an error here will roll back the createUserDocument if it also uses withErrorHandling effectively.
      throw createError(ErrorCode.INTERNAL, "Failed to finalize user setup. Please contact support.", {originalError: dbError.message});
    }

    // Send verification email
    try {
      const sendVerificationEmailRequest = {
        data: {userId: newUserRecord.uid, email, displayName: newUserRecord.displayName},
        auth: {uid: newUserRecord.uid, token: {} as any}, // Mock auth context
      };
      await (sendVerificationEmail as any)(sendVerificationEmailRequest as any);
    } catch (emailError: any) {
      logger.warn(`Failed to send verification email for ${newUserRecord.uid} after signup, but signup succeeded.`, emailError);
      // Don't fail the whole signup if email sending fails, user can request it again.
    }

    return {
      success: true,
      userId: newUserRecord.uid,
      message: "Signup successful. Please check your email to verify your account.",
    };
  }, "signUpWithEmail")
);

// Placeholder for signInWithPhoneNumber - Requires more complex setup with Recaptcha or other verification
export const signInWithPhoneNumber = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.SHORT,
    // secrets: [RECAPTCHA_SECRET_KEY] // If using reCAPTCHA Enterprise
  },
  withErrorHandling(async (/* request */) => { // request is unused
    // const {phoneNumber, recaptchaToken} = request.data;
    // Implementation depends on chosen verification method (e.g., reCAPTCHA, custom OTP service)
    // This is a complex flow involving client-side steps as well.
    logger.warn("signInWithPhoneNumber is not fully implemented yet.");
    throw createError(ErrorCode.UNIMPLEMENTED, "Phone number sign-in is not available at this moment.");
  }, "signInWithPhoneNumber")
);

// Placeholder for verifyPhoneNumber
export const verifyPhoneNumber = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.SHORT,
  },
  withErrorHandling(async () => { // Removed unused request
    // const {verificationId, verificationCode} = request.data;
    logger.warn("verifyPhoneNumber is not fully implemented yet.");
    throw createError(ErrorCode.UNIMPLEMENTED, "Phone number verification is not available at this moment.");
  }, "verifyPhoneNumber")
);

// Placeholder for resendPhoneNumberVerification
export const resendPhoneNumberVerification = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.SHORT,
  },
  withErrorHandling(async () => { // Removed unused request
    // const {phoneNumber, recaptchaToken} = request.data;
    logger.warn("resendPhoneNumberVerification is not fully implemented yet.");
    throw createError(ErrorCode.UNIMPLEMENTED, "Resending phone number verification is not available at this moment.");
  }, "resendPhoneNumberVerification")
);

/**
 * Invites a user to a family tree.
 */
export const inviteUserToFamily = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.MEDIUM,
    secrets: [SENDGRID_APIKEY, SENDGRID_FROMEMAIL, SENDGRID_TEMPLATES_INVITE, FRONTEND_URL],
  },
  withErrorHandling(async (request) => {
    const {auth, data} = request;
    const {
      inviteeEmail,
      inviteeName, // Optional: for a more personal email
      familyTreeId,
      familyTreeName, // Optional: for email context
      // Optional prefill data for the new user if they don't exist
      firstName,
      lastName,
      gender,
      dateOfBirth,
      phoneNumber,
      relationshipToInviter, // e.g., "child", "spouse", "parent"
    } = data;

    if (!auth) {
      throw createError(ErrorCode.UNAUTHENTICATED, "User must be authenticated to send invitations.");
    }
    if (!inviteeEmail || !isValidEmail(inviteeEmail)) {
      throw createError(ErrorCode.INVALID_ARGUMENT, "A valid invitee email address is required.");
    }
    if (!familyTreeId) {
      throw createError(ErrorCode.INVALID_ARGUMENT, "Family Tree ID is required.");
    }

    initSendGrid();
    const db = getFirestore();
    const inviterId = auth.uid;

    const inviterDoc = await db.collection("users").doc(inviterId).get();
    if (!inviterDoc.exists) {
      throw createError(ErrorCode.NOT_FOUND, "Inviter user profile not found.");
    }
    const inviterData = inviterDoc.data() as UserDocument;
    const inviterName = inviterData.displayName || inviterData.firstName || "A family member";

    // Check if inviter has permission to invite to this family tree (e.g., is part of it)
    if (inviterData.familyTreeId !== familyTreeId /* && !inviterData.isAdmin */) {
      // Could also check if inviter is an admin of that specific tree if such a role exists
      throw createError(ErrorCode.PERMISSION_DENIED, "You do not have permission to invite users to this family tree.");
    }

    const invitationToken = generateSecureToken();
    const hashedInvitationToken = hashToken(invitationToken);
    const invitationExpires = Timestamp.fromMillis(Date.now() + 7 * 24 * 3600 * 1000); // 7 days

    const invitationRef = db.collection("familyInvitations").doc(); // Auto-generate ID
    const newInvitation = {
      id: invitationRef.id,
      inviteeEmail: inviteeEmail.toLowerCase(),
      inviteeName: inviteeName || null,
      inviterId,
      inviterName,
      familyTreeId,
      familyTreeName: familyTreeName || "Your Family Tree",
      status: "pending", // pending, accepted, declined, expired
      invitationToken: hashedInvitationToken,
      invitationTokenPlain: invitationToken, // Store plain for link, hash for lookup - consider security implications
      invitationExpires,
      createdAt: FieldValue.serverTimestamp(),
      updatedAt: FieldValue.serverTimestamp(),
      // Prefill data
      prefillData: {
        firstName: firstName || null,
        lastName: lastName || null,
        gender: gender || null,
        dateOfBirth: dateOfBirth || null,
        phoneNumber: phoneNumber || null,
        relationshipToInviter: relationshipToInviter || null,
      },
    };

    await invitationRef.set(newInvitation);

    const fromEmail = SENDGRID_FROMEMAIL.value();
    const inviteTemplateId = SENDGRID_TEMPLATES_INVITE.value();
    const frontendUrlValue = FRONTEND_URL.value();

    if (!fromEmail || !inviteTemplateId || !frontendUrlValue) {
      logger.error("SendGrid configuration secrets are missing for family invitation.");
      await invitationRef.update({status: "failed_config_error"}); // Mark invite as failed
      throw createError(ErrorCode.INTERNAL, "Email service configuration error prevents sending invitation.");
    }

    // Link could go to signup with prefill, or a dedicated accept invite page
    const acceptLink = `${frontendUrlValue}/accept-invitation?token=${invitationToken}`;

    const msg: MailDataRequired = {
      to: inviteeEmail,
      from: {
        email: fromEmail,
        name: "Dynasty App",
      },
      templateId: inviteTemplateId,
      dynamicTemplateData: {
        inviterName: inviterName,
        inviteeName: inviteeName || "Friend",
        familyName: familyTreeName || "their family tree",
        acceptLink: acceptLink,
        // Any other data your template needs
      },
    };

    await sgMail.send(msg);
    logger.info(`Successfully sent invitation email to ${inviteeEmail}`);

    return {
      success: true,
      invitationId: invitationRef.id,
    };
  }, "inviteUserToFamily")
);

/**
 * Handles post-phone number sign-in logic.
 * This function is typically called after a user successfully verifies their phone number.
 *
 * @param request Contains `data` ({ uid: string; phoneNumber: string }) and `auth` (auth context).
 * @returns A promise that resolves with a success or error object.
 */
export const handlePhoneSignIn = onCall(
  {
    region: DEFAULT_REGION,
    timeoutSeconds: FUNCTION_TIMEOUT.SHORT,
  },
  async (request) => {
    // For v2 onCall, data is in request.data
    // Auth context (if user is authenticated when calling) is in request.auth
    const {uid, phoneNumber} = request.data;

    if (!uid) {
      logger.error("handlePhoneSignIn: UID is missing in the request data.");
      throw createError(ErrorCode.INVALID_ARGUMENT, "The function must be called with a 'uid' argument.");
    }
    if (!phoneNumber) {
      logger.error("handlePhoneSignIn: phoneNumber is missing in the request data.");
      throw createError(ErrorCode.INVALID_ARGUMENT, "The function must be called with a 'phoneNumber' argument.");
    }

  logger.info(`handlePhoneSignIn: Processing request for UID: ${uid}, Phone: ${phoneNumber}`);

  try {
    const userRecord = await getAuth().getUser(uid); // Use getAuth() from firebase-admin/auth
    logger.info(`handlePhoneSignIn: Successfully fetched user record for UID: ${uid}`, userRecord.toJSON());

    const db = getFirestore(); // Use getFirestore() from firebase-admin/firestore
    const userDocRef = db.collection("users").doc(uid);
    const userDoc = await userDocRef.get();

    if (!userDoc.exists) {
      logger.info(`handlePhoneSignIn: User document does not exist for UID: ${uid}. Creating new document.`);
      await userDocRef.set({
        uid: uid,
        phoneNumber: phoneNumber,
        email: userRecord.email,
        displayName: userRecord.displayName,
        photoURL: userRecord.photoURL,
        createdAt: FieldValue.serverTimestamp(), // Use FieldValue from firebase-admin/firestore
        onboardingCompleted: false,
      }, {merge: true});
      logger.info(`handlePhoneSignIn: Successfully created user document for UID: ${uid}`);
    } else {
      logger.info(`handlePhoneSignIn: User document already exists for UID: ${uid}. Updating phone number.`);
      await userDocRef.update({
        phoneNumber: phoneNumber,
      });
      logger.info(`handlePhoneSignIn: Successfully updated user document for UID: ${uid}`);
    }

    return {
      success: true,
      message: `User ${uid} processed successfully with phone number ${phoneNumber}.`,
      userId: uid,
    };
  } catch (error: any) {
    logger.error(`handlePhoneSignIn: Error processing UID: ${uid}`, error);
    if (error.code && error.message) {
      throw error; // Re-throw if it's already a properly formatted error
    }
    throw createError(
      ErrorCode.INTERNAL,
      error.message || "An internal error occurred while processing the phone sign-in."
    );
  }
  }
);
