rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }
    
    function isFamilyTreeMember(familyTreeId) {
      let userData = getUserData();
      return userData != null && userData.familyTreeId == familyTreeId;
    }
    
    function isFamilyTreeAdmin(familyTreeId) {
      let treeData = get(/databases/$(database)/documents/familyTrees/$(familyTreeId)).data;
      return treeData != null && treeData.adminUserIds.hasAny([request.auth.uid]);
    }
    
    function isFamilyTreeOwner(familyTreeId) {
      let treeData = get(/databases/$(database)/documents/familyTrees/$(familyTreeId)).data;
      return treeData != null && treeData.ownerUserId == request.auth.uid;
    }
    
    function canAccessStory(storyData) {
      // Use ternary operators and logical expressions instead of if statements
      return storyData.privacy == 'family' ? isFamilyTreeMember(storyData.familyTreeId) :
             storyData.privacy == 'privateAccess' ? isOwner(storyData.authorID) :
             storyData.privacy == 'custom' ? (
               isOwner(storyData.authorID) || 
               (storyData.customAccessMembers != null && 
                storyData.customAccessMembers.hasAny([request.auth.uid]))
             ) : 
             false; // Default to false for unknown privacy settings
    }

    // User profiles
    match /users/{userId} {
      allow read: if isSignedIn() && (
        isOwner(userId) ||
        // Allow family members to read each other's profiles
        exists(/databases/$(database)/documents/families/$(resource.data.familyTreeId)/members/$(request.auth.uid))
      );
      allow create: if isOwner(userId);
      allow update: if isOwner(userId);
      allow delete: if false; // Don't allow users to delete their profile through client
    }
    
    // User settings
    match /userSettings/{userId} {
      allow read: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isOwner(userId);
      allow delete: if isSignedIn() && isOwner(userId);
    }
    
    // Family trees
    match /familyTrees/{treeId} {
      allow read: if isSignedIn() && 
                    (isFamilyTreeMember(treeId) || 
                     resource.data.isPrivate == false);
      allow create: if isSignedIn();
      allow update: if isSignedIn() && 
                      (isFamilyTreeAdmin(treeId) || 
                       isFamilyTreeOwner(treeId));
      allow delete: if isSignedIn() && isFamilyTreeOwner(treeId);
      
      // Tree members permissions
      match /members/{memberId} {
        allow read: if isSignedIn() && isFamilyTreeMember(treeId);
        allow create: if isSignedIn() && 
                        (isFamilyTreeAdmin(treeId) || 
                         isFamilyTreeOwner(treeId) || 
                         resource.data.canAddMembers == true);
        allow update: if isSignedIn() && 
                        (isFamilyTreeAdmin(treeId) || 
                         isFamilyTreeOwner(treeId) || 
                         (resource.data.canEdit == true && isOwner(resource.data.createdBy)));
        allow delete: if isSignedIn() && 
                        (isFamilyTreeAdmin(treeId) || 
                         isFamilyTreeOwner(treeId));
      }
    }
    
    // Stories
    match /stories/{storyId} {
      allow read: if isSignedIn() && canAccessStory(resource.data);
      allow create: if isSignedIn() && request.resource.data.authorID == request.auth.uid;
      allow update: if isSignedIn() && 
                      (isOwner(resource.data.authorID) || 
                      (resource.data.privacy == 'family' && 
                       isFamilyTreeAdmin(resource.data.familyTreeId)));
      allow delete: if isSignedIn() && 
                      (isOwner(resource.data.authorID) || 
                       isFamilyTreeOwner(resource.data.familyTreeId));
    }
    
    // Events
    match /events/{eventId} {
      allow read: if isSignedIn();
      // Add create, update, delete rules as needed, likely through functions for now.
      // For client-side creation (if any direct):
      // allow create: if isSignedIn() && request.resource.data.hostId == request.auth.uid;
      // For client-side update/delete (if any direct and if host can modify):
      // allow update: if isSignedIn() && resource.data.hostId == request.auth.uid;
      // allow delete: if isSignedIn() && resource.data.hostId == request.auth.uid;
    }
    
    // Invitations
    match /invitations/{inviteId} {
      allow read: if isSignedIn() && 
                    (resource.data.inviterId == request.auth.uid || 
                     resource.data.inviteeId == request.auth.uid);
      allow create: if isSignedIn();
      allow update: if isSignedIn() && 
                      (resource.data.inviterId == request.auth.uid || 
                       resource.data.inviteeId == request.auth.uid);
      allow delete: if isSignedIn() && resource.data.inviterId == request.auth.uid;
    }
    
    // Comments
    match /comments/{commentId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && 
                      (resource.data.userId == request.auth.uid || 
                       isFamilyTreeAdmin(resource.data.familyTreeId));
    }
    
    // Story Likes
    match /storyLikes/{likeId} {
      allow read: if isSignedIn();
      allow create: if isSignedIn() && request.resource.data.userId == request.auth.uid;
      allow update: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow delete: if isSignedIn() && resource.data.userId == request.auth.uid;
    }
    
    // Email verification tokens
    match /emailVerificationTokens/{tokenId} {
      allow read: if false;
      allow write: if false; // Only allow through Cloud Functions
    }
    
    // Password reset tokens
    match /passwordResetTokens/{tokenId} {
      allow read: if false;
      allow write: if false; // Only allow through Cloud Functions
    }
    
    // notifications
    match /notifications/{notificationId} {
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow write: if false; // Only through Cloud Functions
    }
    
    // notification preferences
    match /notificationPreferences/{userId} {
      allow read: if isSignedIn() && userId == request.auth.uid;
      allow write: if isSignedIn() && userId == request.auth.uid;
    }
    
    // user devices for notifications
    match /userDevices/{deviceId} {
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow write: if false; // Only through Cloud Functions
    }
    
    // notification analytics (for tracking engagement)
    match /notificationAnalytics/{analyticsId} {
      allow read: if isSignedIn() && resource.data.userId == request.auth.uid;
      allow write: if false; // Only through Cloud Functions
    }
    
    // End-to-end encryption keys
    match /encryptionKeys/{userId} {
      allow read: if isSignedIn(); // Anyone authenticated can read public keys
      allow create: if isSignedIn() && userId == request.auth.uid;
      allow update: if isSignedIn() && userId == request.auth.uid;
      allow delete: if false; // Don't allow deletion of encryption keys
    }
    
    // User's personal key storage
    match /users/{userId}/keys/{keyType} {
      allow read: if isSignedIn() && userId == request.auth.uid;
      allow write: if isSignedIn() && userId == request.auth.uid;
    }
    
    // Key verifications
    match /users/{userId}/keyVerifications/{targetUserId} {
      allow read: if isSignedIn() && 
                    (userId == request.auth.uid || 
                     targetUserId == request.auth.uid);
      allow write: if false; // Only through Cloud Functions
    }
    
    // Encrypted chats
    match /chats/{chatId} {
      allow read: if isSignedIn() && 
                    resource.data.participants.hasAny([request.auth.uid]);
      allow create: if false; // Only through Cloud Functions
      allow update: if false; // Only through Cloud Functions
      allow delete: if false; // Don't allow chat deletion
    }
    
    // User's chat references
    match /users/{userId}/chats/{chatId} {
      allow read: if isSignedIn() && userId == request.auth.uid;
      allow create: if false; // Only through Cloud Functions
      allow update: if isSignedIn() && userId == request.auth.uid;
      allow delete: if false; // Don't allow deletion
    }
    
    // Encrypted messages
    match /chats/{chatId}/messages/{messageId} {
      allow read: if isSignedIn() && 
                    get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]);
      allow create: if isSignedIn() && 
                      get(/databases/$(database)/documents/chats/$(chatId)).data.participants.hasAny([request.auth.uid]) &&
                      request.resource.data.senderId == request.auth.uid;
      allow update: if false; // Messages are immutable
      allow delete: if false; // Messages cannot be deleted
    }
    
    // Signal Protocol Identity Keys
    match /signalKeys/{userId} {
      allow read: if isSignedIn(); // Anyone can read public identity keys
      allow create: if isSignedIn() && userId == request.auth.uid;
      allow update: if isSignedIn() && userId == request.auth.uid;
      allow delete: if false; // Never allow deletion of identity keys
      
      // Device-specific keys
      match /devices/{deviceId} {
        allow read: if isSignedIn();
        allow write: if isSignedIn() && 
                       get(/databases/$(database)/documents/signalKeys/$(userId)).data.userId == request.auth.uid;
      }
    }
    
    // Signal Protocol PreKeys
    match /users/{userId}/prekeys/{prekeyId} {
      allow read: if isSignedIn(); // Anyone can fetch prekeys for key exchange
      allow create: if isSignedIn() && userId == request.auth.uid;
      allow update: if false; // PreKeys are immutable
      allow delete: if isSignedIn() && userId == request.auth.uid; // Allow deletion after use
    }
    
    // Signal Protocol Signed PreKeys
    match /users/{userId}/signedPrekeys/{signedPrekeyId} {
      allow read: if isSignedIn(); // Anyone can fetch signed prekeys
      allow create: if isSignedIn() && userId == request.auth.uid;
      allow update: if false; // Signed PreKeys are immutable
      allow delete: if isSignedIn() && userId == request.auth.uid; // Allow cleanup of old keys
    }
    
    // Key Change Notifications
    match /keyChangeNotifications/{notificationId} {
      allow read: if isSignedIn() && 
                    (resource.data.affectedUserId == request.auth.uid || 
                     resource.data.participants.hasAny([request.auth.uid]));
      allow write: if false; // Only through Cloud Functions
    }
    
    // Session Records (for debugging/audit)
    match /users/{userId}/sessions/{sessionId} {
      allow read: if isSignedIn() && userId == request.auth.uid;
      allow write: if false; // Only through Cloud Functions
    }
    
    // Vault Items
    match /vaultItems/{itemId} {
      allow read: if isSignedIn() && 
        (resource.data.userId == request.auth.uid ||
         request.auth.uid in resource.data.sharedWith);
      allow write: if isSignedIn() && 
        request.auth.uid == resource.data.userId;
    }
    
    // Vault Encryption Keys
    match /vaultKeys/{userId} {
      allow read, write: if isSignedIn() && 
        request.auth.uid == userId;
    }
    
    // Vault Audit Logs
    match /vaultAuditLogs/{logId} {
      allow read: if isSignedIn() && 
        resource.data.userId == request.auth.uid;
      allow write: if false; // Only through functions
    }
    
    // Vault Security Incidents
    match /vaultSecurityIncidents/{incidentId} {
      allow read: if isSignedIn() && 
        request.auth.uid in resource.data.admins;
      allow write: if false; // Only through functions
    }
    
    // Vault Share Links
    match /vaultShareLinks/{linkId} {
      allow read: if isSignedIn() && 
        (resource.data.createdBy == request.auth.uid ||
         resource.data.isPublic == true);
      allow write: if false; // Only through functions
    }
    
    // Vault File Metadata
    match /vaultFileMetadata/{fileId} {
      allow read: if isSignedIn() && 
        (resource.data.ownerId == request.auth.uid ||
         request.auth.uid in resource.data.sharedWith);
      allow write: if false; // Only through functions
    }
    
    // Subscription Documents
    match /subscriptions/{subscriptionId} {
      // Users can only read their own subscription
      // Family plan members can read the family owner's subscription
      allow read: if isSignedIn() && (
        subscriptionId == request.auth.uid ||
        (resource.data.plan == 'family' && 
         resource.data.familyMembers != null &&
         request.auth.uid in resource.data.familyMembers.map(m => m.userId))
      );
      // All writes must go through Cloud Functions for security
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
    
    // Subscription History (audit trail)
    match /subscriptionHistory/{historyId} {
      // Users can read their own subscription history
      allow read: if isSignedIn() && 
        resource.data.userId == request.auth.uid;
      // Only Cloud Functions can write history
      allow write: if false;
    }
    
    // Referral Documents
    match /referrals/{referralId} {
      // Users can read referrals they created or were referred by
      allow read: if isSignedIn() && (
        resource.data.referrerUserId == request.auth.uid ||
        resource.data.referredUserId == request.auth.uid
      );
      // Only Cloud Functions can create/update referrals
      allow write: if false;
    }
    
    // Stripe Webhook Events (for debugging/audit)
    match /stripeWebhookEvents/{eventId} {
      // Only admins can read webhook events
      allow read: if isSignedIn() && 
        getUserData() != null && 
        getUserData().isAdmin == true;
      // Only Cloud Functions can write webhook events
      allow write: if false;
    }
    
    // Subscription Analytics (aggregated data)
    match /subscriptionAnalytics/{analyticsId} {
      // Only admins can read analytics
      allow read: if isSignedIn() && 
        getUserData() != null && 
        getUserData().isAdmin == true;
      // Only Cloud Functions can write analytics
      allow write: if false;
    }
  }
}